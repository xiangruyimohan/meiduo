import refrom rest_framework import serializersfrom django_redis import get_redis_connectionfrom rest_framework_jwt.settings import api_settingsfrom .utils import check_save_user_tokenfrom users.models import Userfrom .models import QQAuthUser, OAuthSinaUserclass QQAuthUserSerializer(serializers.Serializer):    """绑定用户的序列化器"""    access_token = serializers.CharField(label='操作凭证')    mobile = serializers.RegexField(label='手机号', regex=r'^1[3-9]\d{9}$')    password = serializers.CharField(label='密码', max_length=20, min_length=8)    sms_code = serializers.CharField(label='短信验证码')    def validate(self, attrs):        access_token = attrs.get('access_token')  # 获取出加密的openid        openid = check_save_user_token(access_token)        if not openid:            raise serializers.ValidationError('openid无效')        attrs['access_token'] = openid  # 把解密后的openid保存到反序列化的大字典中以备后期绑定用户时使用        # 验证短信验证码是否正确        redis_conn = get_redis_connection('verify_codes')        # 获取当前用户的手机号        mobile = attrs.get('mobile')        real_sms_code = redis_conn.get('sms_%s' % mobile)        # 获取前端传过来的验证码        sms_code = attrs.get('sms_code')        if real_sms_code.decode() != sms_code:  # 注意redis中取出来的验证码是bytes类型注意类型处理            raise serializers.ValidationError('验证码错误')        try:            # 判断手机号是已存在用户的还是新用户            user = User.objects.get(mobile=mobile)        except User.DoesNotExist:            # 如果出现异常说明是新用户            pass        else:            # 表示此手机号是已注册过的用户            if not user.check_password(attrs.get('password')):                raise serializers.ValidationError('已存在用户,但密码不正确')            else:                attrs['user'] = user        return attrs    def create(self, validated_data):        """把openid和user进行绑定"""        user = validated_data.get('user')        if not user:  # 如果用户是不存在的,那就新增一个用户            user = User(                username=validated_data.get('mobile'),                password=validated_data.get('password'),                mobile=validated_data.get('mobile')            )            user.set_password(validated_data.get('password'))  # 对密码进行加密            user.save()        # 让user和openid绑定        QQAuthUser.objects.create(            user=user,            openid=validated_data.get('access_token')        )        return userclass WeiboOauthSerializer(serializers.ModelSerializer):    """微博验证序列化器"""    mobile = serializers.CharField(max_length=11)    sms_code = serializers.CharField(max_length=6, min_length=6, write_only=True)    access_token = serializers.CharField(write_only=True)  # 反序列化输出    # 序列化输出    token = serializers.CharField(read_only=True)    user_id = serializers.IntegerField(read_only=True)    class Meta:        model = User        fields = ('password', 'mobile', 'username', 'sms_code', 'token', 'access_token', 'user_id')        extra_kwargs = {            'username':{'read_only':True},            'password':{'write_only':True}        }    def validated_mobile(self, value):        """"验证手机号"""        if not re.match(r'1[3-9]\d{9}$', value):            raise serializers.ValidationError('手机号格式错误')        return value    def validate(self, attrs):        """验证access_token"""        # serializer = Serializer(settings.SECRET_KEY, 600)        # try:        #     # 解析token        #     data = serializer.loads(attrs['access_token'])        # except:        #     raise serializers.ValidationError('无效的token')        #        # # 获取weibotoken        # weibotoken = data.get('weibotoken')        # # attrs中添加weibotoken        # attrs['weibotoken'] = weibotoken        # # 验证短信验证码:        # rel_sms_code = SMSCodeView.get(attrs["mobile"])        # if not rel_sms_code:        #     raise serializers.ValidationError('短信验证码失效')        #        # # 比对用户输入短信和redis中真实短信        # if attrs['sms_code'] != rel_sms_code:        #     raise serializers.ValidationError('短信验证不一致')        # 获取短信验证码是否正确        redis_conn = get_redis_connection('verify_codes')        # 获取当前用户的手机号        mobile = attrs.get('mobile')        real_sms_code = redis_conn.get('sms_%s' % mobile)        # 获取前端传过来的验证码        sms_code = attrs.get('sms_code')        if not real_sms_code:            raise serializers.ValidationError("验证码失效")        # 注意redis中取出来的验证码时bytes类型需要decode        if real_sms_code.decode() != sms_code:            raise serializers.ValidationError('验证码错误')        # 验证手机号是否被注册过        try:            user = User.objects.get(mobile=attrs['mobile'])        except:            # 未注册过,注册为新用户            return attrs        else:            # 注册过 查询用户进行绑定            # 判断密码            if not user.check_password(attrs['password']):                raise serializers.ValidationError('密码错误')            else:                attrs['user'] = user        return attrs    def create(self, validated_data):        """保存用户"""        user = validated_data.get('user', None)        if user is None:            # 创建用户            user = User.objects.create_user(                username=validated_data['mobile'],                password=validated_data['password'],                mobile=validated_data['mobile']            )        OAuthSinaUser.objects.create(user=user, access_token=validated_data['access_token'])        # user_id = user.id        # 生成加密后的token数据        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER        payload = jwt_payload_handler(user)  # 生成载荷部分        token = jwt_encode_handler(payload)  # 生成token        user.token = token        user.user_id = user.id        return user